<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Wheel Turtle CLUB Firmware Update</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <style>
    :root{--brand:#003366;--brand2:#004080;--panel:#eef6ff;}
    body{font-family:Arial,Helvetica,sans-serif;background:#f5f5f5;margin:0;padding:0;}
    
    /* Navbar */
    .navbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: #003366;
      padding: 15px 40px;
      color: white;
    }

    .navbar .logo {
      font-size: 24px;
      font-weight: bold;
      letter-spacing: 1px;
    }

    .navbar ul {
      list-style: none;
      display: flex;
      margin: 0;
      padding: 0;
      align-items: center;
    }

    .navbar ul li {
      margin: 0 15px;
    }

    .navbar ul li a {
      text-decoration: none;
      color: white;
      font-size: 16px;
    }

    .navbar ul li a:hover {
      text-decoration: underline;
    }
    
    .page-content {
      padding: 24px;
    }
    .container{max-width:920px;margin:0 auto;background:#fff;padding:28px;border-radius:14px;box-shadow:0 10px 24px rgba(0,0,0,.08);}
    h2{margin:0 0 18px;color:var(--brand);text-align:center}
    .step{background:var(--panel);border-left:6px solid var(--brand);border-radius:10px;padding:18px;margin:18px 0}
    .step h3{margin:0 0 10px;color:var(--brand)}
    .status{margin:10px 0;color:#333}
    .version{margin:6px 0 0;color:#111;font-weight:bold}
    button{background:var(--brand2);border:0;color:#fff;padding:10px 16px;border-radius:8px;cursor:pointer}
    button:hover{background:#0059b3}
    button:disabled{background:#aab3c2;cursor:not-allowed}
    .form-group{margin-bottom:15px}
    .form-group label{display:block;margin-bottom:8px;color:var(--brand);font-weight:bold;font-size:14px}
    .form-group select{width:100%;padding:10px;border:2px solid #c9d6ef;border-radius:8px;font-size:14px;box-sizing:border-box;background:white}
    .file-list{margin-top:15px}
    .file-item{background:#fff;border:2px solid #dbe6f9;padding:12px;border-radius:8px;margin-bottom:10px;display:flex;justify-content:space-between;align-items:center;cursor:pointer;transition:0.3s}
    .file-item:hover{background:#f0f8ff;border-color:#004080}
    .file-item.selected{background:#cce0ff;border-color:#004080}
    .file-info{flex-grow:1}
    .file-name{font-weight:bold;color:#003366;font-size:15px}
    .file-meta{font-size:12px;color:#666;margin-top:4px}
    .file-radio{width:20px;height:20px;cursor:pointer}
    .empty{color:#666;font-style:italic;margin:10px 0;text-align:center}
    .spinner{border:3px solid #f3f3f3;border-top:3px solid #004080;border-radius:50%;width:40px;height:40px;animation:spin 1s linear infinite;display:none;margin:20px auto}
    @keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
    .selected-file-box{background:#d4edda;border:2px solid #28a745;padding:15px;border-radius:8px;margin-top:15px;display:none}
    .selected-file-box h4{margin:0 0 10px 0;color:#155724}
    .selected-file-box p{margin:5px 0;color:#155724;font-size:14px}
    .log{background:#f9f9f9;border:1px solid #ddd;padding:8px;margin:8px 0;max-height:120px;overflow-y:auto;font-family:monospace;font-size:11px}
    .refresh-btn{background:#17a2b8;padding:8px 12px;font-size:13px;margin-left:10px}
    .refresh-btn:hover{background:#138496}
    .header-with-refresh{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}
    
    /* Disconnect Modal */
    .disconnect-modal{
      display:none;
      position:fixed;
      top:0;
      left:0;
      width:100%;
      height:100%;
      background:rgba(0,0,0,0.7);
      z-index:9999;
      align-items:center;
      justify-content:center;
    }
    .disconnect-modal.show{display:flex}
    .disconnect-content{
      background:white;
      padding:30px;
      border-radius:15px;
      text-align:center;
      max-width:400px;
      box-shadow:0 10px 40px rgba(0,0,0,0.3);
    }
    .disconnect-content h3{
      color:#dc3545;
      margin:0 0 15px 0;
      font-size:24px;
    }
    .disconnect-content p{
      color:#666;
      margin:10px 0 20px 0;
      font-size:16px;
    }
    .disconnect-content button{
      background:#004080;
      color:white;
      border:none;
      padding:12px 30px;
      border-radius:8px;
      font-size:16px;
      cursor:pointer;
    }
    .disconnect-content button:hover{
      background:#0059b3;
    }
  </style>
</head>
<body>
  <!-- Navbar -->
  <div class="navbar">
    <div class="logo">WHEEL TURTLE CLUB</div>
    <ul>
      <li><a href="firmware-select.html">Home</a></li>
      <li><a href="wtc-update.html">Firmware Update</a></li>
      <li><a href="#" onclick="logout(); return false;">Logout</a></li>
    </ul>
  </div>

  <div class="page-content">
  <!-- Disconnect Modal -->
  <div id="disconnectModal" class="disconnect-modal">
    <div class="disconnect-content">
      <h3>‚ö†Ô∏è Device Disconnected</h3>
      <p>The Bluetooth connection has been lost.</p>
      <p>The page will reset in 30 seconds.</p>
      <button onclick="resetPage()">Restart Now</button>
    </div>
  </div>

  <div class="container">
    <h2>Wheel Turtle Club Firmware Update</h2>

    <!-- Step 1 -->
    <div class="step">
      <h3>Step 1: Connect Device</h3>
      <p>Turn on Bluetooth and click below. Only devices starting with <b>TPWT</b> will be shown.</p>
      <p><i>No other teamplus devices or apps should be connected to bluetooth for the update to be successful.</i></p>
      <button id="pairBtn">Connect</button>
      <p class="status" id="connectionStatus">Status: Not connected</p>
      <p class="status" id="deviceInfo">Device: ‚Äî</p>
      <p class="version" id="availableVersion">Current Version: (unknown)</p>
    </div>

    <!-- Step 2 -->
    <div class="step">
      <div class="header-with-refresh">
        <h3 style="margin:0">Step 2: Choose Firmware File</h3>
        <button class="refresh-btn" onclick="loadFirmwareFiles()" title="Refresh firmware list">üîÑ Refresh</button>
      </div>
      <div class="spinner" id="fileSpinner"></div>
      <div class="file-list" id="fileList">
        <div class="empty">Loading firmware files...</div>
      </div>
    </div>

    <!-- Step 3 -->
    <div class="step">
      <h3>Step 3: Update Device</h3>
      <p>Connect your device (Step 1) and select a firmware file (Step 2), then click Update.</p>
      
      <div class="selected-file-box" id="selectedFileBox">
        <h4>‚úì Selected Firmware:</h4>
        <p><strong>File:</strong> <span id="selectedFileName"></span></p>
        <p><strong>Directory:</strong> <span id="selectedFileDir"></span></p>
        <p><strong>Size:</strong> <span id="selectedFileSize"></span></p>
        <p><strong>Version:</strong> <span id="selectedFileVersion"></span></p>
      </div>
      
      <div id="noFileSelected" class="empty">No firmware file selected yet.</div>
      
      <button id="updateBtn" disabled style="margin-top:15px">Update Device</button>
      
      <div style="margin-top:15px;">
        <div id="progressText">Progress: 0%</div>
        <div style="height:10px;background:#dde;border-radius:6px;overflow:hidden;margin-top:6px;">
          <div id="progressBar" style="height:100%;width:0;background:#2e6ad7;transition:width .15s linear"></div>
        </div>
        <p style="text-align:center;color:#666;font-size:13px;margin:8px 0;font-style:italic;">This may take up to 3-5 minutes</p>
        <div id="resultMsg" class="status" style="margin-top:6px;"></div>
      </div>
      <div class="log" id="bleLog"></div>
    </div>
  </div>

<script>
/* ========= CONFIG ========= */
const API_BASE = 'http://localhost:3000';
const OTA_SERVICE_UUID = '00001ff5-0000-1000-8000-00805f9b34fb';
const OTA_CONTROL_UUID = '000000fa-0000-1000-8000-00805f9b34fb';
const OTA_DATA_UUID = '000000fb-0000-1000-8000-00805f9b34fb';
const SETTINGS_UUID = '00000008-0000-1000-8000-00805f9b34fb';
const FIRMWARE_DIRECTORY = 'Wheel-Turtle-Club';

/* ========= LOGOUT & AUTH ========= */
function logout() {
  if (confirm('Are you sure you want to logout?')) {
    localStorage.removeItem('authToken');
    localStorage.removeItem('userRole');
    localStorage.removeItem('userEmail');
    alert('Logged out successfully');
    window.location.href = 'index.html';
  }
}

window.addEventListener('DOMContentLoaded', () => {
  const token = localStorage.getItem('authToken');
  if (!token) {
    alert('Please login to access firmware updates');
    window.location.href = 'index.html';
    return;
  }
  loadFirmwareFiles();
});

/* ========= DOM HOOKS ========= */
const pairBtn = document.getElementById('pairBtn');
const connectionStatus = document.getElementById('connectionStatus');
const deviceInfo = document.getElementById('deviceInfo');
const availableVersion = document.getElementById('availableVersion');
const fileList = document.getElementById('fileList');
const fileSpinner = document.getElementById('fileSpinner');
const updateBtn = document.getElementById('updateBtn');
const selectedFileBox = document.getElementById('selectedFileBox');
const noFileSelected = document.getElementById('noFileSelected');
const selectedFileName = document.getElementById('selectedFileName');
const selectedFileDir = document.getElementById('selectedFileDir');
const selectedFileSize = document.getElementById('selectedFileSize');
const selectedFileVersion = document.getElementById('selectedFileVersion');
const progressBar = document.getElementById('progressBar');
const progressText = document.getElementById('progressText');
const resultMsg = document.getElementById('resultMsg');
const bleLog = document.getElementById('bleLog');
const disconnectModal = document.getElementById('disconnectModal');

/* ========= STATE ========= */
let btDevice = null;
let gattServer = null;
let otaControlChar = null;
let otaDataChar = null;
let settingsChar = null;
let selectedFile = null;
let updateInProgress = false;
let updateCompleted = false;
let transferSuccessful = false;

/* ========= UTIL ========= */
function log(msg) {
  const timestamp = new Date().toLocaleTimeString();
  bleLog.innerHTML += `[${timestamp}] ${msg}\n`;
  bleLog.scrollTop = bleLog.scrollHeight;
  console.log(msg);
}

function humanSize(bytes) {
  if (!bytes) return '';
  const u = ['B','KB','MB','GB']; let i=0; let n=+bytes;
  while (n>=1024 && i<u.length-1) { n/=1024; i++; }
  return `${n.toFixed(1)} ${u[i]}`;
}

function setProgress(fraction) {
  const pct = Math.max(0, Math.min(100, Math.round((fraction || 0) * 100)));
  progressBar.style.width = pct + '%';
  progressText.textContent = `Progress: ${pct}%`;
}

async function calculateMD5(data) {
  const wordArray = CryptoJS.lib.WordArray.create(data);
  const hash = CryptoJS.MD5(wordArray);
  return hash.toString(CryptoJS.enc.Hex);
}

const td = new TextDecoder('utf-8');
const te = new TextEncoder();

function parseConfigLine(str) {
  const parts = (str || '').trim().split(',');
  const model = parts[10] || '(unknown model)';
  const fw = parts[12] || '(unknown version)';
  return { model, fw };
}

function isConnected() {
  return !!(btDevice && btDevice.gatt && btDevice.gatt.connected);
}

function resetPage() {
  log('Resetting page...');
  location.reload();
}

function showDisconnectModal() {
  disconnectModal.classList.add('show');
}

async function ensureConnected() {
  if (!btDevice) throw new Error('No device selected');
  if (!isConnected()) {
    log('Reconnecting...');
    connectionStatus.textContent = 'Status: Reconnecting‚Ä¶';
    gattServer = await btDevice.gatt.connect();
    connectionStatus.textContent = 'Status: Connected';
    await discoverOTACharacteristics();
  }
  if (!otaControlChar || !otaDataChar) {
    throw new Error('OTA characteristics not found');
  }
}

function extractVersion(filename) {
  const versionMatch = filename.match(/v?(\d+\.\d+\.?\d*)/i);
  if (versionMatch) return versionMatch[1];
  
  const dateMatch = filename.match(/(\d{8})/);
  if (dateMatch) {
    const date = dateMatch[1];
    return `${date.substr(0,4)}-${date.substr(4,2)}-${date.substr(6,2)}`;
  }
  
  return filename.replace('.bin', '');
}

/* ========= STEP 1: BLUETOOTH ========= */
async function discoverOTACharacteristics() {
  log('Discovering OTA characteristics...');
  otaControlChar = null;
  otaDataChar = null;
  settingsChar = null;

  try {
    const services = await gattServer.getPrimaryServices();
    
    for (const svc of services) {
      try {
        const chars = await svc.getCharacteristics();
        
        for (const ch of chars) {
          const uuid = ch.uuid.toLowerCase();
          
          if (uuid.includes('00fa') || uuid.includes('0xfa')) {
            otaControlChar = ch;
            log('Found OTA Control characteristic');
          }
          if (uuid.includes('00fb') || uuid.includes('0xfb')) {
            otaDataChar = ch;
            log('Found OTA Data characteristic');
          }
          if (uuid.includes('0008') || uuid.includes('0x08')) {
            settingsChar = ch;
            log('Found Settings characteristic');
          }
        }
      } catch (e) {
        console.error('Error getting characteristics:', e);
      }
    }

    if (otaControlChar && otaControlChar.properties.notify) {
      await otaControlChar.startNotifications();
      otaControlChar.addEventListener('characteristicvaluechanged', e => {
        const msg = td.decode(e.target.value);
        log(`Device: ${msg}`);
        
        if (msg.includes('RESULT,OK')) {
          updateCompleted = true;
          log('‚úì Device confirmed: Update successful!');
          showSuccessMessage();
        } else if (msg.includes('RESULT,FAIL')) {
          updateCompleted = true;
          log('‚úó Device reported: Update failed');
          showFailureMessage(msg);
        } else if (msg.includes('PROGRESS')) {
          const match = msg.match(/PROGRESS,(\d+)/);
          if (match) setProgress(parseInt(match[1]) / 100);
        }
      });
      log('Subscribed to OTA control notifications');
    }

    if (settingsChar && settingsChar.properties.notify) {
      let settingsReceived = false;
      await settingsChar.startNotifications();
      settingsChar.addEventListener('characteristicvaluechanged', e => {
        if (settingsReceived) return;
        settingsReceived = true;
        
        const s = td.decode(e.target.value);
        const parsed = parseConfigLine(s);
        if (parsed.model !== '(unknown model)') {
          deviceInfo.textContent = `Device: ${parsed.model}`;
          log(`Device model: ${parsed.model}`);
        }
        if (parsed.fw !== '(unknown version)') {
          availableVersion.textContent = `Current Version: ${parsed.fw}`;
          log(`Current firmware: ${parsed.fw}`);
        }
      });
      log('Subscribed to settings notifications');
    }

  } catch (e) {
    console.error('Error discovering characteristics:', e);
    throw new Error('Failed to discover OTA characteristics');
  }

  if (!otaControlChar || !otaDataChar) {
    throw new Error('Required OTA characteristics not found.');
  }
}

pairBtn.addEventListener('click', async () => {
  try {
    bleLog.innerHTML = '';
    updateInProgress = false;
    updateCompleted = false;
    transferSuccessful = false;
    connectionStatus.textContent = 'Status: Connecting‚Ä¶';
    log('Requesting Bluetooth device...');

    btDevice = await navigator.bluetooth.requestDevice({
      filters: [{ namePrefix: 'TPWT' }],
      optionalServices: [OTA_SERVICE_UUID, 0x1800, 0x1801, 0x180a]
    });

    log(`Selected device: ${btDevice.name}`);

    btDevice.addEventListener('gattserverdisconnected', () => {
      log('‚ö†Ô∏è DEVICE DISCONNECTED!');
      
      // If we completed the transfer and sent END command successfully
      if (transferSuccessful && !updateCompleted) {
        // Wait a moment to see if we got a RESULT message
        setTimeout(() => {
          if (!updateCompleted) {
            // Device disconnected after successful transfer - this is expected behavior
            log('‚úì Device disconnected after firmware transfer (expected - device is rebooting)');
            updateCompleted = true;
            showSuccessMessage();
          }
        }, 2000);
        return;
      }
      
      // If update was already marked as successful - the showSuccessMessage() will handle reset
      if (updateCompleted && transferSuccessful) {
        log('Device disconnected after successful update (expected behavior)');
        return;
      }
      
      // If we're in the middle of an update and it failed
      if (updateInProgress && !transferSuccessful) {
        log('‚úó Device disconnected during update (unexpected)');
        showFailureMessage('Device disconnected during firmware transfer');
        updateInProgress = false;
        
        // Show modal for failed update
        connectionStatus.textContent = 'Status: Disconnected';
        connectionStatus.style.color = '#dc3545';
        updateBtn.disabled = true;
        showDisconnectModal();
        
        setTimeout(() => {
          resetPage();
        }, 30000);
        return;
      }
      
      // If not updating, show disconnect modal (unexpected disconnect)
      if (!updateInProgress && !transferSuccessful) {
        connectionStatus.textContent = 'Status: Disconnected';
        connectionStatus.style.color = '#dc3545';
        updateBtn.disabled = true;
        
        showDisconnectModal();
        
        setTimeout(() => {
          resetPage();
        }, 30000);
      }
    });

    gattServer = await btDevice.gatt.connect();
    connectionStatus.textContent = 'Status: Connected';
    connectionStatus.style.color = '#00aa00';
    log('GATT server connected');

    await discoverOTACharacteristics();
    
    if (selectedFile) {
      updateBtn.disabled = false;
    }

  } catch (err) {
    console.error('Bluetooth connect error:', err);
    log(`Error: ${err.message || err}`);
    connectionStatus.textContent = 'Status: Failed to connect';
    connectionStatus.style.color = '#dc3545';
    availableVersion.textContent = 'Current Version: (unavailable)';
  }
});

/* ========= SUCCESS/FAILURE DISPLAY ========= */
function showSuccessMessage() {
  resultMsg.style.color = '#00aa00';
  resultMsg.style.backgroundColor = '#d4edda';
  resultMsg.style.padding = '15px';
  resultMsg.style.borderRadius = '8px';
  resultMsg.style.border = '2px solid #00aa00';
  resultMsg.innerHTML = '‚úÖ <strong style="font-size:18px;">Update Successful!</strong><br><span style="font-size:14px;">Device is rebooting. Page will reset automatically in <span id="countdown">5</span> seconds...</span>';
  
  progressBar.style.background = '#00aa00';
  setProgress(1);
  updateBtn.disabled = true;
  
  // Countdown and auto-reset
  let countdown = 5;
  const countdownInterval = setInterval(() => {
    countdown--;
    const countdownElement = document.getElementById('countdown');
    if (countdownElement) {
      countdownElement.textContent = countdown;
    }
    if (countdown <= 0) {
      clearInterval(countdownInterval);
      log('Auto-resetting page for reconnection...');
      resetPage();
    }
  }, 1000);
}

function showFailureMessage(errorMsg) {
  resultMsg.style.color = '#cc0000';
  resultMsg.style.backgroundColor = '#f8d7da';
  resultMsg.style.padding = '15px';
  resultMsg.style.borderRadius = '8px';
  resultMsg.style.border = '2px solid #cc0000';
  resultMsg.innerHTML = `‚ùå <strong style="font-size:16px;">Update Failed</strong><br><span style="font-size:14px;">${errorMsg || 'Device verification failed. Please try again.'}</span>`;
  
  progressBar.style.background = '#cc0000';
}

/* ========= STEP 2: FILE BROWSER ========= */
async function loadFirmwareFiles() {
  try {
    fileSpinner.style.display = 'block';
    fileList.innerHTML = '';

    const response = await fetch(`${API_BASE}/api/files?directory=${encodeURIComponent(FIRMWARE_DIRECTORY)}`);
    const data = await response.json();

    fileSpinner.style.display = 'none';

    if (data.ok && data.files.length > 0) {
      const binFiles = data.files.filter(file => file.name.endsWith('.bin'));
      
      if (binFiles.length > 0) {
        binFiles.forEach((file, index) => {
          const fileItem = createFileItem(file, index);
          fileList.appendChild(fileItem);
        });
        log(`Found ${binFiles.length} firmware file(s)`);
      } else {
        fileList.innerHTML = '<div class="empty">No .bin files found. Contact admin to upload firmware files.</div>';
        log('No .bin files available');
      }
    } else {
      fileList.innerHTML = '<div class="empty">No firmware files available. Contact admin to upload firmware files.</div>';
      log('No firmware files found');
    }
  } catch (error) {
    fileSpinner.style.display = 'none';
    fileList.innerHTML = `<div class="empty" style="color:#dc3545;">Error loading files. Check connection.</div>`;
    log(`Error loading files: ${error.message}`);
  }
}

function createFileItem(file, index) {
  const div = document.createElement('div');
  div.className = 'file-item';
  div.id = `file-${index}`;

  const fileInfo = document.createElement('div');
  fileInfo.className = 'file-info';

  const fileName = document.createElement('div');
  fileName.className = 'file-name';
  fileName.textContent = file.name;

  const fileMeta = document.createElement('div');
  fileMeta.className = 'file-meta';
  fileMeta.innerHTML = `Size: ${humanSize(file.size)} | Modified: ${new Date(file.modified).toLocaleString()}`;

  fileInfo.appendChild(fileName);
  fileInfo.appendChild(fileMeta);

  const radio = document.createElement('input');
  radio.type = 'radio';
  radio.name = 'fileSelection';
  radio.className = 'file-radio';
  radio.value = index;

  div.appendChild(fileInfo);
  div.appendChild(radio);

  radio.addEventListener('change', () => {
    selectFile(file, div);
  });

  div.addEventListener('click', (e) => {
    if (e.target !== radio) {
      radio.checked = true;
      selectFile(file, div);
    }
  });

  return div;
}

function selectFile(file, itemElement) {
  document.querySelectorAll('.file-item').forEach(item => {
    item.classList.remove('selected');
  });

  itemElement.classList.add('selected');

  selectedFile = {
    name: file.name,
    directory: FIRMWARE_DIRECTORY,
    size: file.size,
    url: `${API_BASE}${file.url}`,
    version: extractVersion(file.name)
  };

  selectedFileName.textContent = selectedFile.name;
  selectedFileDir.textContent = 'Wheel Turtle Club';
  selectedFileSize.textContent = humanSize(selectedFile.size);
  selectedFileVersion.textContent = selectedFile.version;

  selectedFileBox.style.display = 'block';
  noFileSelected.style.display = 'none';
  
  updateBtn.disabled = !isConnected();
  
  log(`Selected: ${selectedFile.name} (${humanSize(selectedFile.size)})`);
}

function clearFileSelection() {
  selectedFile = null;
  selectedFileBox.style.display = 'none';
  noFileSelected.style.display = 'block';
  updateBtn.disabled = true;
  document.querySelectorAll('.file-item').forEach(item => {
    item.classList.remove('selected');
  });
}

/* ========= STEP 3: UPDATE ========= */
async function sendTextCommand(characteristic, text) {
  await ensureConnected();
  const payload = te.encode(text);
  await characteristic.writeValue(payload);
  log(`Sent: ${text}`);
}

async function writeChunks(characteristic, data, chunkSize = 512) {
  await ensureConnected();
  let sent = 0;
  const total = data.length;
  
  log(`Starting data transfer: ${total} bytes in ${chunkSize}-byte chunks`);
  
  while (sent < total) {
    const end = Math.min(sent + chunkSize, total);
    const chunk = data.slice(sent, end);
    
    try {
      await characteristic.writeValue(chunk);
      
      if (sent % 102400 < chunkSize) {
        log(`Sent ${sent} / ${total} bytes`);
      }
      
    } catch (e) {
      log(`Write error at byte ${sent}: ${e.message}`);
      if (String(e?.message||e).toLowerCase().includes('disconnected')) {
        await ensureConnected();
        continue;
      }
      throw e;
    }
    
    sent = end;
    setProgress(sent / total);
  }
  
  log(`Data transfer complete: ${sent} bytes sent`);
}

async function performOTAUpdate(firmwareData) {
  try {
    // Reset state
    updateInProgress = true;
    updateCompleted = false;
    transferSuccessful = false;
    
    // Reset UI
    resultMsg.textContent = '';
    resultMsg.style.color = '#333';
    resultMsg.style.backgroundColor = 'transparent';
    resultMsg.style.padding = '0';
    resultMsg.style.border = 'none';
    setProgress(0);
    progressBar.style.background = '#2e6ad7';
    
    log('Starting OTA update sequence...');
    
    log('Step 1: Entering update mode...');
    await sendTextCommand(otaControlChar, 'enter update mode');
    await new Promise(r => setTimeout(r, 1000));
    
    log('Step 2: Calculating MD5 hash...');
    const md5Hash = await calculateMD5(firmwareData);
    log(`Firmware size: ${firmwareData.length} bytes, MD5: ${md5Hash}`);
    
    log('Step 3: Sending START command with MD5...');
    const startCmd = `START,size=${firmwareData.length},md5=${md5Hash}`;
    await sendTextCommand(otaControlChar, startCmd);
    await new Promise(r => setTimeout(r, 2000));
    
    log('Step 4: Streaming firmware data...');
    resultMsg.textContent = 'Uploading firmware...';
    resultMsg.style.color = '#333';
    
    await writeChunks(otaDataChar, firmwareData, 448);
    
    log('Firmware transfer complete');
    
    // Mark transfer as successful BEFORE sending END
    // because data transfer is already complete at this point
    transferSuccessful = true;
    
    log('Step 5: Sending END command...');
    
    // Try to send END command, but don't fail if device disconnects
    try {
      await sendTextCommand(otaControlChar, 'END');
      log('END command sent successfully');
    } catch (endError) {
      log(`Note: ${endError.message} (This may be normal - device is processing the update)`);
    }
    
    log('Update process complete. Waiting for device confirmation...');
    resultMsg.textContent = 'Firmware sent successfully. Waiting for device to apply update...';
    
    // Wait up to 10 seconds for device to respond or disconnect
    await new Promise(resolve => {
      let completed = false;
      
      const checkInterval = setInterval(() => {
        if (updateCompleted || !isConnected()) {
          if (!completed) {
            completed = true;
            clearInterval(checkInterval);
            
            if (!updateCompleted) {
              // Device disconnected without sending RESULT - this is success
              updateCompleted = true;
              log('‚úì Device applying update (disconnected for reboot)');
              showSuccessMessage();
            }
            resolve();
          }
        }
      }, 500);
      
      // Timeout after 10 seconds
      setTimeout(() => {
        if (!completed) {
          completed = true;
          clearInterval(checkInterval);
          
          if (!updateCompleted) {
            updateCompleted = true;
            log('‚úì No response from device, but transfer was successful');
            showSuccessMessage();
          }
          resolve();
        }
      }, 10000);
    });
    
  } catch (e) {
    // Only show error if transfer wasn't successful
    if (!transferSuccessful) {
      console.error('OTA update error:', e);
      log(`ERROR: ${e.message || e}`);
      showFailureMessage(e.message || e);
    } else {
      // Transfer was successful, ignore any errors (device is rebooting)
      log('Transfer completed successfully. Device is applying the update.');
      if (!updateCompleted) {
        updateCompleted = true;
        showSuccessMessage();
      }
    }
  } finally {
    updateInProgress = false;
  }
}

updateBtn.addEventListener('click', async () => {
  try {
    if (!otaControlChar || !otaDataChar) {
      return alert('Please connect to a device first (Step 1)');
    }
    if (!selectedFile) {
      return alert('Please select a firmware file (Step 2)');
    }
    
    log(`Downloading firmware: ${selectedFile.name}`);
    resultMsg.textContent = 'Downloading firmware...';
    resultMsg.style.color = '#333';
    resultMsg.style.backgroundColor = 'transparent';
    resultMsg.style.padding = '0';
    resultMsg.style.border = 'none';
    
    const res = await fetch(selectedFile.url, { cache: 'no-store' });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    
    const arrayBuf = await res.arrayBuffer();
    const data = new Uint8Array(arrayBuf);
    
    log(`Downloaded ${humanSize(data.length)}`);
    
    await performOTAUpdate(data);
    
  } catch (e) {
    console.error(e);
    log(`ERROR: ${e.message || e}`);
    showFailureMessage(e.message || e);
  }
});
</script>

  </div> <!-- End page-content -->
</body>
</html>
